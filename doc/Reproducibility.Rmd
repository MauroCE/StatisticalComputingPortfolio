---
title: "Reproducibility"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 4
bibliography: bibliography.bib
runtime: shiny
nocite: |
  @shiny, @turingway
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Strategies for Reproducibility

According to @sc1 reproducibility can be implemented by:

* Organize files logically into *modules* and *packages*.
* Use *version control* software.
* Write human-readable *documentation*.

Why is reproducibility important? 

* If the research is reproducible, then the analysis and the methodology are clear.
* A major building block of the scientific method is the reproducibility of experiements. If independent researchers are able to reproduce our results, this will 

#### Replication crisis
**Replication crisis** refers to the difficulty or impossibility to reproduce scientific studies, which undermines their results since the reproducibility of experiments is an integral part of the scientific method. Methods to address the crisis include:

* Make our research reproducible.
* Submission of **registered reports**

Our research is said to be reproducible when it is possible to reproduce the same analysis and conclusions given the same raw data. Unfortunately, much of the research done up to date is irreproducible because:

* It was difficult to create code that would work seemlessly on different computer systems.
* Not all data-engineering or data cleaning steps were reported.

A registered report is a description of the methodology of the study and of the analyses **before** data collection. The registered report is peer-reviewed, and this guarantees that the author of the study follows a certain protocol, reducing the changes that questionable research practices are introduced.

#### Literate Programming
One way of making our research more reproducible is by providing human-readable code and documentation explaining the functionalities, limits and features of our code. Documentation, however, can often be neglected and quickly become outdated, which makes our code less intellegible. One way around this issue is **literate programming**. Literate programming combines code and documentation into the same source code, so that when code is updated, we can also update the documentation, and this should lead to a much more up-to-date documentation. One of the best ways of doing literate programming in R is to use **Rmarkdown**.

#### R Markdown
An R Markdown file is recognizable by the `.rmd` extension. It comprises:

* A YAML header that specifies metadata such as author, title, bibliography file, and the type of output document. This section is at the top of the file and it embedded between `---` before and after. For instance, the YAML file for this R Markdown is as follows
  ```{r, eval=FALSE}
  ---
  title: "Reproducibility"
  output:
    html_document:
      toc: true
      toc_float: true
      toc_depth: 4
  bibliography: bibliography.bib
  ---
  ```
  the `output` field defines what type of document we want at the end (HTML, PDF, etc), `toc` stands for "table of contents" and in the YAML above we've allowed it to show headers up to 4 levels and to "float", i.e. to be always present at the side of the file, even when scrolling down through the document. 
* Chunks of code and (optional) their output, such as the following:
  ```{r}
  x <- matrix(1:6, 2, 3)
  dim(x)
  ```
  Code chucnks are encapsulated by a pair of three consecutive backticks. After the first, curly braces are used to specify which programming language is being used and several options that go along with that code chunk, such as whether to display the output and whether the code chunk should be evaluated. For instance, to specify R code we can use `{r}`.
* Markdown.

The process to create an Rmarkdown works as follows: when we `knit` the document, the `knitr` package grabs all the code chunks, executes them and combines together the markdown text with the code and its (optional) output. Then, a free open-source document converter called `pandoc` transforms this combined markdown document into the desired output format, which usually is either HTML or PDF.

In the following, we'll see several features of R markdown.

## RMarkdown playground
Headers are defined by hastags. The biggest header uses only one `#`, and the smallest one uses six of them `######`. Text can be written in *italics* by surrounding it with one pair of `*`. Using a pair of double asteriscs `**` we obtain **bold text**. Equations can be written inline by using one pair of dollar signs $x = z + y$ and similarly we can have an indented equation by using a pair of double dollar signs `$$` $$x = z + y$$
R markdown is extremely flexible because we can also add images to the markdown file by using the following syntax `![image_title](path/to/image.png)` 

![image](/home/za19162/Pictures/flatwallpaper.jpg)

Tables can also be constructed all in markdown

Leftmost header | Rightmost header
----------------|-----------------
lefmost cell    | rightmost cell
bottomleft cell | bottom right cell

Code can either be evaluated and its output shown, as demonstrated above, or the code can just appear without being evaluated by`knitr` using the option`{r, eval=FALSE}`.

```{r, eval=FALSE}
x <- matrix(1:6, 2, 3)
dim(x)
```
To only display the output, one can use `{r, echo=FALSE}` to obtain
```{r, echo=FALSE}
x <- matrix(1:6, 2, 3)
dim(x)
```

The R markdown can be made interactive with Shiny, by adding the option `runtime: shiny` in the YAML file. Let's create a very basic data frame and then we will let the user decide the number of rows to display:

```{r}
m <- matrix(1:60, 20, 3)
df <- data.frame(m)
```
Then we create the interactive plot:
```{r, echo=FALSE}
numericInput("rows", "How many rows?", 3)

renderTable({
  head(df, input$rows)
})
```



## Bibliography
