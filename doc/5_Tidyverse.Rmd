---
title: "Tidyverse Portfolio: Spotify and Kaggle Data"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(plotly)
library(forcats)
library(reshape2)
library(magrittr)
```

Import the spotify data
```{r}
spotify <- read_csv("top50.csv", col_names=c(
  "index", "Song", "Artist", "Genre", "BPM", "Energy", "Danceability",
  "Loudness", "Liveness", "Valence", "Length", "Acousticness", "Speechiness", "Popularity"),
  col_types=cols(
    index=col_double(),
    Song=col_factor(),
    Artist=col_factor(),
    Genre=col_factor()), 
  skip=1)
```
Drop the column "index" cause its useless
```{r}
spotify <- spotify %>% select(-c("index"))
```
# Genre Popularity
For brevity, will change the name of the genres and change one of the artists cause it has a non-utf-8 name,
```{r}
levels(spotify$Genre) <- c(
  "CanPop", "ReggaeFlow", "DancePop", "Pop", "DfwRap", "Trap", "CountryRap",
  "ElecPop", "Reggaeton", "PanPop", "CanadaHH", "Latin", "EscapeRoom", 
  "PopHouse", "AustrPop", "EDM", "AltHH", "BigRoom", "BoyBand", "R&Besp",
  "Brostep"
)
levels(spotify$Artist) <- c(
  "Shawn Mendes", "Anuel AA", "Ariana Grande", "Ed Sheeran", "Post Malone",
  "Lil Tecca", "Sam Smith", "Lil Nas X", "Billie Eilish", "Bad Bunny",
  "DJ Snake", "Lewis Capaldi", "Sech", "Drake", "Chris Brown",
  "J Balvin", "Y2K", "Lizzo", "MEDUZA", "Jhay Cortez","Lunay", "Tones and I",
  "Ali Gatie", "Daddy Yankee", "The Chainsmokers", "Maluma", "Young Thug",
  "Katy Perry", "Martin Garrix", "Jonas Brothers", "Lauv", "Kygo", 
  "Taylor Swift", "Lady Gaga", "Khalid","ROSALÃ¬A", "Marshmello", "Nicky Jam"  
)
```


```{r, fig.width=10, fig.height=7}
p <- ggplot(data=spotify) + 
  geom_bar(aes(x=Genre, fill=Artist)) + 
  coord_polar() + 
  theme(axis.text.x=element_text(size=12)) + 
  labs(y="Number of Songs per Genre", title="Top 50 Spotify Songs by Genre by Artist") + 
  theme(plot.title=element_text(hjust=0.5))
p
```



```{r}
# First, create new dataframe where we re-order the factor
spotify_ordered <- within(spotify, Genre <- factor(Genre, levels=names(sort(table(Genre), decreasing=TRUE))))
#forcats::fct_infreq(Genre)
p <- ggplot(data=spotify_ordered) + 
  geom_bar(aes(x=Genre, fill=Artist)) + 
  coord_flip() + 
  theme(axis.text.x=element_text(size=12)) + 
  labs(y="Number of Songs per Genre", title="Top 50 Spotify Songs by Genre by Artist", x="Genre") + 
  theme(plot.title=element_text(hjust=0.5))
ggplotly(p)
```

# Correlation of Variables
Let's see the correlation between variables.
```{r, fig.width=15, warning=FALSE}
# create function to set to NA all upper triangular part of the matrix
upper_tri_to_na <- function(matrix){
  matrix[upper.tri(matrix)] <- NA
  return(matrix)
}
# Find the melted correlation matrix (should I add/remove BPM?)
melted_corrmatrix <- spotify %>%
  select(-c(Genre, Artist, Song)) %>% cor %>%
  upper_tri_to_na %>% 
  melt %>% 
  mutate(value=round(value, digits=2))
# Plot correlation plot
ggplot(melted_corrmatrix, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile(color="white") + 
  geom_text(aes(x=Var1, y=Var2, label=value), color="grey90", size=10) +
  theme(axis.text.x=element_text(size=15),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_text(size=15),
        plot.title=element_text(hjust=0.5, size=20),
        legend.title=element_text(size=15),
        legend.text=element_text(size=12)) + 
  ggtitle("Correlation between Song Features") +
  labs(fill="Correlation") + 
  scale_fill_continuous(na.value="grey91")
```


# Kaggle Kernels
```{r}
kaggle <- read_csv("kagglekernels.csv", col_types = cols(
  Votes=col_double(),
  Owner=col_factor(),
  Kernel=col_factor(),
  Dataset=col_factor(),
  Output=col_character(),
  `Code Type`=col_factor(),
  Language=col_factor(),
  Comments=col_double(),
  Views=col_double(),
  Forks=col_double()
))
```

## Work 1
Need to use `kaggle$Output` to extract the number of visualizations and the number of data files outputted by each kernel.

`filter(kaggle, str_detect(Output, "This script outputs "))` this kinda works. Maybe also `kaggle %>% filter(str_detect(Output, "This script outputs ")) %>% filter(str_detect(Output, "visualizations and "))` helps.


Also this grabs the number of visualizations

```
str_extract(kaggle$Output, "(?<=This script outputs )(.*)(?= visualizatio(n\\.$|ns\\.$))")
```
This grabs the number of data files only
```
str_extract(kaggle$Output, "(?<=This script outputs )(.*)(?= data fil(e\.|es\.))")
```

and this grabs the number of data files

```
str_extract(kaggle$Output, "(?<=visualizations and )(.*)(?= data fil)")
```

```{r}
# Grab the ones that output NOTHING
no_out <- str_extract(kaggle$Output, "(^This script doesn't output)")
# everything else flag
some_output_ind <- is.na(no_out)
# Get dataframe with EVERYTHING ELSE (some output)
some_output <- kaggle %>% filter(some_output_ind)
# Extract visualizations only
viz <- str_extract(kaggle$Output, "(?<=This script outputs )(.*)(?= visualizatio(n\\.$|ns\\.$))")
# INDECES OF THOSE THAT DONT OUTPUT NOTHING & DONT ONLY OUTPUT VIZ
some_noviz_ind <- some_output_ind & is.na(viz)
# now extract those with viz (and data files)
vizfiles <- str_extract(kaggle$Output, "(?<=This script outputs )(.*)(?= visualizatio(n|ns) and)")
# similarly, extract those with (viz and) data files
filesviz <- str_extract(kaggle$Output, "(?<=visualizatio(ns|n) and )(.*)(?= data fil)")
# get indeces for everything else (basically only data files)
only_files <- some_noviz_ind & is.na(filesviz)
# now get everything ending with data files, then we basically get those indeces and 
# check them against the current indeces
ending_datafiles <- str_extract(kaggle$Output, "(?<=This script outputs )(.*)(?= data fil(es|e)\\.$)")
# check them against, grab the correct indeces. Basically where we have both viz and 
# data files, we set them to NA
ending_datafiles[!only_files] <- NA
```

Now its time to put everything together somehow. We need to cast all of them to numeric.
```{r}
# Number of data files by DATA FILES ONLY
files_only <- as.double(ending_datafiles)
# Number of Visualizations by VIZ ONLY
viz_only <- as.double(viz)
# Number of visualizations for viz + data files
viz_and_datafiles <- as.double(vizfiles)
datafiles_and_viz <- as.double(filesviz)
```
Now we use `mutate` to create new columns. One column will be `output_viz` and one `output_files`. In order to do that, we need to calculate the total number of visualizations and the total number of output files. This is not hard because they should be unique.
```{r}
# Instantiate with all zeroes
output_viz <- rep(0, nrow(kaggle))
output_files <- rep(0, nrow(kaggle))
# At the correct indeces, add viz only.
output_viz[!is.na(viz_only)] <- viz_only[!is.na(viz_only)]
# at the correct indeces, add viz (+ data files)
output_viz[!is.na(viz_and_datafiles)] <- viz_and_datafiles[!is.na(viz_and_datafiles)]
# At the correct indeces, add files only
output_files[!is.na(files_only)] <- files_only[!is.na(files_only)]
# At the correct indeces, add files (+ viz)
output_files[!is.na(datafiles_and_viz)] <- datafiles_and_viz[!is.na(datafiles_and_viz)]
# finally use mutate to create these two new columns (try assignment pipe)
kaggle <- kaggle %<>% mutate(output_viz=output_viz, output_files=output_files) %>% 
  select(-Output)
```


# Tags, Programming Languages and File Types

Python seems to be the most utilized languages among the top-voted kernels. Let's see how this changes if we also group them by code type. Code type has two options `Script` or `Notebook`. Notice that we want to group by code type first, and then by language. Not the other way around.
```{r}
kaggle %>% 
  group_by(`Code Type`, Language) %>% 
  count %>% 
  ggplot(aes(x=`Code Type`, y=n, color=Language, fill=Language, label=paste(n))) + 
    geom_bar(position="dodge", stat="identity", alpha=0.2) + 
    labs(x="Submission File Type", y="Number of Kernels", 
         title="Programming Language and File Type Popularity in Top-Voted Kaggle Kernels") + 
    geom_text(size=5, position=position_dodge2(width=0.9), show.legend = FALSE, vjust=-0.2) 
```

We can also look at the tag frequency in the top-voted kaggle kernels.

```{r}
# Get a dataframe with a column for every tag. Values in that column are 0 or 1s depending if
# that kernel was tagged with it.
tagcount <- kaggle  %>% 
    select(Tags) %>%  
    mutate(rn=row_number()) %>%    # Add a col with row indeces
    separate_rows(Tags, sep="\\s*,\\s*") %>%  # RegEx comma-separated tags
    mutate(i1=1) %>%                          # Add column to uniquely identify
    mutate_all(~na_if(., "")) %>%     # remove NA values generated by "<tag>,"
    pivot_wider(names_from = Tags, 
                values_from = i1,
                values_fill = list(i1 = 0)) %>% # Wide format
    select(-rn) %>% # remove row index
  colSums %>%       # sum up the tag count
  t
# Notice that NA values during `pivot_wider` will be cast to strings in order
# to become column names. We therefore need to get rid of it. Get a flat saying 
# which elements of the named vector `tagcount` are not "NA".
flag <- dimnames(tagcount)[[2]] != "NA"
# Use flat to get tags, values and the correct ordering
tags <- dimnames(tagcount)[[2]][flag]
tagcount <- tagcount[flag]
order_ind <- tagcount %>% order(decreasing=TRUE)
# now order both the tagcount and the names
tagcount <- tagcount[order_ind]
tags <- tags[order_ind]
# finally put everything together into a dataframe
tagcountdf <- tibble(tag=as.factor(tags), count=as.double(tagcount))
# let's consider tags used 5 times or more
tagcountdf %<>% subset(count>=5)
# finally, plot this
p <- ggplot(data=tagcountdf, aes(x=tag, y=count)) + 
  geom_bar(stat="identity", color="white", width=1.0) + 
  coord_flip() + 
  theme(axis.text.x=element_text(size=9),
        axis.title.x=element_text(size=15),
        axis.text.y=element_text(size=9),
        axis.title.y=element_text(size=15)) + 
  labs(x="Tags Used More then 5 times", 
       title="Most Popular Tags in Top-Voted Kaggle Kernels",
       y="Number of Occurrencies") + 
  scale_y_continuous(expand=c(0,0), limits = c(0, max(tagcount)+0.1)) + 
  scale_x_discrete(limits=tagcountdf$tag)
ggplotly(p)
```


































